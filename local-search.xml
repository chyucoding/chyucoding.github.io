<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tomcat性能优化策略</title>
    <link href="/2020/11/15/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2020/11/15/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="Tomcat优化策略："><a href="#Tomcat优化策略：" class="headerlink" title="Tomcat优化策略："></a>Tomcat优化策略：</h3><ol><li>系统性能指标的衡量指标，主要是响应时间和吞吐量</li></ol><ul><li><p>响应时间：执行某一个操作的耗时；</p></li><li><p>吞吐量：系统在给定时间内能够支持的事务数量，一个事务表示 一个Client向Server发送一个请求，然后Server做出响应的过程；</p></li></ul><ol start="2"><li>Tomcat性能优化从两个方面进行：</li></ol><ul><li>JVM 虚拟机优化（优化内存模型）；</li><li>Tomcat自身配置的优化（比如是否使用了共享线程池？IO模型？）；</li></ul><p><strong>JVM虚拟机优化</strong></p><p>Java虚拟机的运行优化主要是内存分配和垃圾回收策略的优化；</p><p>内存直接影响响应时间和吞吐量；</p><p>GC垃圾回收机制会不同程度的导致程序运行中断；</p><p><a href="https://imgchr.com/i/DFigPI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/15/DFigPI.png" alt="DFigPI.png"></a></p><p><strong>修改配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JAVA_OPTS=<span class="hljs-string">"-server -Xms2048m -Xmx2048m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m"</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JAVA_OPTS=<span class="hljs-string">"-server -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m -Xms512M -Xmx1024M -XX:MaxNewSize=384m -Xss256k"</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JAVA_OPTS=<span class="hljs-string">"-XX:+UseConcMarkSweepGC</span><br></code></pre></td></tr></table></figure><p><strong>Tomcat自身配置的优化</strong></p><ul><li>调整Tomcat线程池</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">Executor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"commonThreadPool"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">namePrefix</span>=<span class="hljs-string">"thread-exec-"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"200"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">maxIdleTime</span>=<span class="hljs-string">"60000"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">maxQueueSize</span>=<span class="hljs-string">"Integer.MAX_VALUE"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">prestartminSpareThreads</span>=<span class="hljs-string">"false"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">threadPriority</span>=<span class="hljs-string">"5"</span></span><br><span class="hljs-tag">    <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.StandardThreadExecutor"</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">"tomcatThreadPool"</span></span><br><span class="hljs-tag">           <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><br><span class="hljs-tag">           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><br><span class="hljs-tag">           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>调整Tomcat/conf/server.xml 中关于连接器的配置以提升服务器的性能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">executor</span>=<span class="hljs-string">"commonThreadPool"</span>  可以指定自己的线程池，</span><br><span class="hljs-tag">              <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"1000"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">"1000"</span>             接收请求与<span class="hljs-attr">maxThreads</span>保持一致</span><br><span class="hljs-tag">              <span class="hljs-attr">maxConnections</span>=<span class="hljs-string">"1000"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>         连接超时</span><br><span class="hljs-tag">              <span class="hljs-attr">compression</span>=<span class="hljs-string">"on"</span>              要不要启动<span class="hljs-attr">gzip</span>压缩</span><br><span class="hljs-tag">              <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">"2048"</span>      压缩最小大小</span><br><span class="hljs-tag">              <span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">"true"</span>         禁用上传超时时间</span><br><span class="hljs-tag">              <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>                重定向</span><br><span class="hljs-tag">              <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>禁用AJP连接器</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Define an AJP 1.3 Connector on port 8009</span><br><span class="hljs-comment">AJP 协议连接端口 协议 重定向的端口号</span><br><span class="hljs-comment">--&gt;</span><br> <span class="hljs-comment">&lt;!-- 这里默认是打开的</span><br><span class="hljs-comment">&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;</span><br><span class="hljs-comment">  --&gt;</span><br></code></pre></td></tr></table></figure><ul><li>调整IO模式</li></ul><p>Tomcat8之前的默认版本使用BIO（阻塞式IO）,对于每一个请求都要创建一个线程进行处理，不适合高并发；Tomcat8以后的版本默认使用NIO模式（非阻塞时IO）；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--org.apache.coyote.http11.Http11NioProtocol --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：当Tomcat8并发性能要求或者出现瓶颈的时候，我们需要尝试使用APR（Apache Portable Runtime）模式，这个是从操作系统层面进行解决异步IO问题，使用时需要在操作系统上安装APR和native；</p><ul><li>动静分离</li></ul><p>可以使用Nginx+Tomcat相结合的部署方案，Nginx负责静态资源访问，Tomcat负责Jsp等动态资源进行访问（因为Tomcat不擅长处理静态资源）；</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用AMQP操作四种交换器(面试题)</title>
    <link href="/2020/11/11/%E4%BD%BF%E7%94%A8AMQP%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E5%99%A8/"/>
    <url>/2020/11/11/%E4%BD%BF%E7%94%A8AMQP%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="使用AMQP操作四种交换器"><a href="#使用AMQP操作四种交换器" class="headerlink" title="使用AMQP操作四种交换器"></a>使用AMQP操作四种交换器</h3><p>交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在RabbitMQ中支持四种交换器:</p><ol><li><p>Direct Exchange：直连交换器（默认）。通过路由键明确指定存储消息的一个队列。</p></li><li><p>Fanout Exchange：扇形交换器。把消息发送给所有绑定的队列。</p></li><li><p>Topic Exchange：主题交换器。按照路由规则，把消息发送给多个队列。</p></li><li><p>Header Exchange：首部交换器。比Direct多了一些头部消息，平时使用较少。</p><p><strong>注意：</strong>只有direct交换器有（AMQP default），当使用direct交换器时，如果没有明确指定名称，走的是第一个AMQP default交换器，也是明确指定名称。但是其他交换器没有默认的，都需要指定名称，只要类型相同，执行哪个交换器是没有什么区别的。</p></li></ol><h5 id="1-direct交换器"><a href="#1-direct交换器" class="headerlink" title="1. direct交换器"></a>1. direct交换器</h5><p>direct交换器是RabbitMQ默认交换器。客户端向direct类型交换器发送消息时，direct会根据路由键把消息放入到指定的队列中。</p><p>如果队列有多个Consumer，会进行公平调度，每个消费者依次取出消息。</p><p><strong>代码演示：</strong></p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.128</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">icoop</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">icoop</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">30m</span><br></code></pre></td></tr></table></figure><p>Publisher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> top.icoop.pojo.User;<br><span class="hljs-keyword">import</span> top.icoop.publisher.PublisherApp;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@SpringBootTest</span>(classes = &#123;PublisherApp<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><br><span class="hljs-class">@<span class="hljs-title">RunWith</span>(<span class="hljs-title">SpringRunner</span>.<span class="hljs-title">class</span>)</span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestSpringAMQPPublisher</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同步消息。</span><br><span class="hljs-comment">     * RabbitMQ支持同步消息。不推荐使用。会降低消息发送方的性能。</span><br><span class="hljs-comment">     * RabbitMQ推荐使用异步消息。消息发送，不等待结果反馈。</span><br><span class="hljs-comment">     * 在特殊情况下，可能需要消息回执。如：邮件回执。</span><br><span class="hljs-comment">     * 互联网项目中。一般都会在订单处理、秒杀逻辑等逻辑中使用同步消息。会+一个异常处理机制，避免超时问题。</span><br><span class="hljs-comment">     * 默认环境下，同步消息的发送方，只等待1秒。没有反馈，抛出异常。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSyncMessage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object result = amqpTemplate.convertSendAndReceive(<span class="hljs-string">"sync-ex"</span>,<br>                    <span class="hljs-string">"sync-routing-key"</span>, <span class="hljs-string">"发送同步消息，并等待结果"</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == result) &#123;<br>                System.out.println(<span class="hljs-string">"服务器太忙，请等待，或先处理其他事务。。。。"</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(result);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">// e.printStackTrace();</span><br>            System.out.println(<span class="hljs-string">"异常位置"</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user.log.info  用户info1  用户info2</span><br><span class="hljs-comment">     * user.log.error  用户error1   用户error2</span><br><span class="hljs-comment">     * user.log.*  用户info1/2  用户error1/2  用户warn1  用户debug1</span><br><span class="hljs-comment">     * order.log.info  订单info</span><br><span class="hljs-comment">     * order.log.error   订单error</span><br><span class="hljs-comment">     * order.log.*  订单info  订单error  订单debug</span><br><span class="hljs-comment">     * *.log.*  全部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTopic</span><span class="hljs-params">()</span></span>&#123;<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.info"</span>, <span class="hljs-string">"用户info日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.info"</span>, <span class="hljs-string">"用户info日志2"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.error"</span>, <span class="hljs-string">"用户error日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.error"</span>, <span class="hljs-string">"用户error日志2"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.warn"</span>, <span class="hljs-string">"用户warn日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"user.log.debug"</span>, <span class="hljs-string">"用户debug日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"order.log.info"</span>, <span class="hljs-string">"订单info日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"order.log.error"</span>, <span class="hljs-string">"订单error日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"order.log.debug"</span>, <span class="hljs-string">"订单debug日志1"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"log-ex-topic"</span>, <span class="hljs-string">"product.log.info"</span>, <span class="hljs-string">"产品info日志1"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到fanout交换器时，路由键可以设定任意值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFanout</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>            amqpTemplate.convertAndSend(<span class="hljs-string">"fanout-ex"</span>, <span class="hljs-string">"fanout-key-"</span>+i, <span class="hljs-string">"消息"</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConsumerCluster</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>            amqpTemplate.convertAndSend(<span class="hljs-string">"first-direct-ex"</span>, <span class="hljs-string">"bjsxt.key2"</span>, <span class="hljs-keyword">new</span> User(i, <span class="hljs-string">"name"</span>+i));<br>            System.out.println(<span class="hljs-string">"发送消息序号-"</span>+i);<br>            <span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">                Thread.sleep(1000);</span><br><span class="hljs-comment">            &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">                e.printStackTrace();</span><br><span class="hljs-comment">            &#125;*/</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendUserMessage</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">10</span>, <span class="hljs-string">"admin"</span>);<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"first-direct-ex"</span>, <span class="hljs-string">"bjsxt.key2"</span>, user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AMQP发送消息的时候，要求消息体内容对象必须可序列化。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendStringMessage1</span><span class="hljs-params">()</span></span>&#123;<br>        String message = <span class="hljs-string">"这是第一个消息"</span>;<br>        amqpTemplate.convertAndSend(<span class="hljs-string">"first-direct-ex"</span>, <span class="hljs-string">"bjsxt.key1"</span>, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.icoop.direct.consumer.handler;<br><br><span class="hljs-keyword">import</span> top.icoop.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理消息的具体类型。</span><br><span class="hljs-comment"> * 需要被Spring容器管理。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectQueueConsumer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义方法。</span><br><span class="hljs-comment">     * 处理消息的方法。</span><br><span class="hljs-comment">     * 方法要求：</span><br><span class="hljs-comment">     *  1、 没有返回值。</span><br><span class="hljs-comment">     *  2、 公开</span><br><span class="hljs-comment">     *  3、 参数是消息内容的具体类型。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 方法处理哪一个队列中的消息，由注解描述。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RabbitListener</span> - 代表当前方法监听的RabbitMQ队列描述。</span><br><span class="hljs-comment">     *  属性 - bindings ： 描述队列、交换器、路由键的绑定规则。</span><br><span class="hljs-comment">     *    属性类型是： <span class="hljs-doctag">@QueueBinding</span>[]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@QueueBinding</span> - 用于描述具体的绑定规则。</span><br><span class="hljs-comment">     *  属性 -</span><br><span class="hljs-comment">     *    value - 队列描述。类型是<span class="hljs-doctag">@Queue</span></span><br><span class="hljs-comment">     *    exchange - 交换器描述。 类型是<span class="hljs-doctag">@Exchange</span></span><br><span class="hljs-comment">     *    key - 路由键描述。 类型是String。合法字符串即可。包含字母、数字、'.'</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Queue</span> - 用于描述一个队列信息。 如果队列已存在，直接监听。如果队列不存在，自动创建。</span><br><span class="hljs-comment">     *  属性 -</span><br><span class="hljs-comment">     *    name - 队列命名。合法字符串。包含字母、数字、'.'、'-'、'_'</span><br><span class="hljs-comment">     *    autoDelete - 队列是不是一个自动删除的队列。默认为""。可选值是： "true" | "false"</span><br><span class="hljs-comment">     *      "true" - 自动删除的队列。如果没有任何的Consumer监听这个队列。RabbitMQ自动删除。</span><br><span class="hljs-comment">     *      "false" - 不删除的队列。创建后，永久保存的队列。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Exchange</span> - 用于描述一个交换器。存在直接连接。不存在自动创建。</span><br><span class="hljs-comment">     *  属性 -</span><br><span class="hljs-comment">     *    name - 交换器名称。字符串。包含字母、数字、'-'、'_'、'.'</span><br><span class="hljs-comment">     *    type - 交换器类型。字符串。可选值：direct、fanout、topic、headers。注意大小写敏感。默认direct</span><br><span class="hljs-comment">     *    autoDelete - 是否自动删除。如果没有任何的绑定队列，自动删除。默认"false"。</span><br><span class="hljs-comment">     *      可选值： "true" | "false"</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"first-direct-queue1"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"first-direct-ex"</span>, autoDelete = <span class="hljs-string">"false"</span>, type = <span class="hljs-string">"direct"</span>),<br>                    key = <span class="hljs-string">"bjsxt.key1"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"接受到的消息是："</span>+message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"first-direct-queue2"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"first-direct-ex"</span>, autoDelete = <span class="hljs-string">"false"</span>, type = <span class="hljs-string">"direct"</span>),<br>                    key = <span class="hljs-string">"bjsxt.key2"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessageWithUser</span><span class="hljs-params">(User user)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"接受到的消息是："</span>+user);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-fanout交换器"><a href="#2-fanout交换器" class="headerlink" title="2. fanout交换器"></a>2. fanout交换器</h5><p>扇形交换器，实际上做的事情就是广播，fanout会把消息发送给所有的绑定在当前交换器上的队列。对应Consumer依然采用公平调度方式。</p><p>使用场景：商品下订单时，同时需要发送邮件、发送短信、向库房发送订单等多个操作同步执行时，可以使用fanout交换器。</p><p><strong>代码演示：</strong></p><p>Consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.icoop.fanout.consumer.handler;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fanout交换器： 扇形交换器。也叫广播交换器。</span><br><span class="hljs-comment"> *  交换器绑定的所有队列，路由键都是'#'。代表全部。</span><br><span class="hljs-comment"> *  消息的发送者，发送消息到交换器，交换器把相同的消息复制若干份，投递到绑定的所有队列中。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过注解做fanout交换器和队列绑定的时候，路由键配置可以省略，即使配置key属性，RabbitMQ忽略。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutConsumer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"fanout-queue-1"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"fanout-ex"</span>, type = <span class="hljs-string">"fanout"</span>)<br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage1</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"队列1 - "</span>+ str);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"fanout-queue-2"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"fanout-ex"</span>, type = <span class="hljs-string">"fanout"</span>),<br>                    key = <span class="hljs-string">"fanout-key2"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage2</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"队列2 - "</span> + str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-topic交换器"><a href="#3-topic交换器" class="headerlink" title="3.topic交换器"></a>3.topic交换器</h5><p>topic比direct交换器功能更强，设置路由键时允许出现特殊字符。</p><p>使用topic时路由键的写法和包写法相同。例如：com.bjsxt.xxxx.xxx格式。</p><p>在绑定时可以带有下面特殊符号，中间可以出现:</p><p>* : 代表一个单词（两个.之间内容）</p><p># : 0个或多个字符</p><p><strong>代码演示：</strong></p><p>Consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.icoop.topic.consumer.handler;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * topic交换器：主题交换器。功能最完整的交换器。相对最复杂的交换器。</span><br><span class="hljs-comment"> *  topic对路由键的管理，是基于规则的。</span><br><span class="hljs-comment"> *   1、 绝对路由键|常量路由键。 路由键的值是固定值，只包含字母、数字、'_'、'-'、'.'</span><br><span class="hljs-comment"> *       如： key-1、 bjsxt-message-for-student-1等。</span><br><span class="hljs-comment"> *       这种路由键匹配规则的topic功能，和direct一样。只有路由键匹配的时候，才投递消息。</span><br><span class="hljs-comment"> *   2、 匹配路由键、 路由键中包括字符'*'或'#'。</span><br><span class="hljs-comment"> *       *代表一个单词，多个单词使用'.'分隔。 如： log.user.*、log.*.info、log.order.*等。</span><br><span class="hljs-comment"> *       #代表多个单词。相当于全部key。使用#作为所有队列的路由键，那么相当于fanout交换器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicConsumer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"user-info-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"user.log.info"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForUserInfo</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"user info日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"user-error-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"user.log.error"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForUserError</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"user error日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"user-all-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"user.log.*"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForUserAll</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"user All日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"order-info-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"order.log.info"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForOrderInfo</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"order info日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"order-error-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"order.log.error"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForOrderError</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"order error日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"order-all-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"order.log.*"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForOrderAll</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"order All日志 ： "</span> + info);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;<br>            <span class="hljs-meta">@QueueBinding</span>(<br>                    value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"all-log-queue"</span>, autoDelete = <span class="hljs-string">"false"</span>),<br>                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"log-ex-topic"</span>, type = <span class="hljs-string">"topic"</span>),<br>                    key = <span class="hljs-string">"*.log.*"</span><br>            )<br>    &#125;)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageForAll</span><span class="hljs-params">(String info)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"All日志 ： "</span> + info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Java实现一个简单（前序 中序 后序）二叉树</title>
    <link href="/2020/11/11/%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/11/11/%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="使用Java实现一个简单（前序-中序-后序）的二叉树"><a href="#使用Java实现一个简单（前序-中序-后序）的二叉树" class="headerlink" title="使用Java实现一个简单（前序 中序 后序）的二叉树"></a>使用Java实现一个简单（前序 中序 后序）的二叉树</h3><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ol><li>创建一个空树类；</li><li>创建一个根节点类；</li><li>创建一个测试类；</li><li>使用递归的思想进行遍历；</li></ol><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><p><strong>空树类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> icoop</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/11 9:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个空数类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br>    <span class="hljs-comment">//    设置一个根节点</span><br>    <span class="hljs-keyword">private</span> TreeNode root;<br><br>    <span class="hljs-comment">//   提供一个set和get方法</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.root = root;<br>    &#125;<br><br>    <span class="hljs-comment">//    提供前序 中序 后序的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">frontShow</span><span class="hljs-params">()</span> </span>&#123;<br>        root.frontShow();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midShow</span><span class="hljs-params">()</span> </span>&#123;<br>        root.midShow();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterShow</span><span class="hljs-params">()</span> </span>&#123;<br>        root.afterShow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根节点类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> icoop</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/11 10:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">根节点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-comment">//    节点的权</span><br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-comment">//    左节点</span><br>    TreeNode leftNode;<br>    <span class="hljs-comment">//    右节点</span><br>    TreeNode rightNode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-comment">//设置左节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeftNode</span><span class="hljs-params">(TreeNode leftNode)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.leftNode = leftNode;<br>    &#125;<br><br>    <span class="hljs-comment">//设置右节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRightNode</span><span class="hljs-params">(TreeNode rightNode)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.rightNode = rightNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">frontShow</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(value);<br>        <span class="hljs-keyword">if</span> (leftNode != <span class="hljs-keyword">null</span>) &#123;<br>            leftNode.frontShow();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightNode != <span class="hljs-keyword">null</span>) &#123;<br>            rightNode.frontShow();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midShow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (leftNode != <span class="hljs-keyword">null</span>) &#123;<br>            leftNode.midShow();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightNode != <span class="hljs-keyword">null</span>) &#123;<br>            rightNode.midShow();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterShow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (leftNode != <span class="hljs-keyword">null</span>) &#123;<br>            leftNode.afterShow();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightNode != <span class="hljs-keyword">null</span>) &#123;<br>            rightNode.afterShow();<br>        &#125;<br>        System.out.println(value);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> icoop</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/11 11:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBinaryTree</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个树</span><br>        BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();<br><span class="hljs-comment">//        创建一个根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//        将根节点赋值给树</span><br>        binaryTree.setRoot(root);<br><span class="hljs-comment">//        创建一个左节点</span><br>        TreeNode treeNodeL = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//        将新创建的节点设置为根节点的子节点</span><br>        root.setLeftNode(treeNodeL);<br><br><span class="hljs-comment">//        创建一个右节点</span><br>        TreeNode treeNodeR = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//        将新创建的节点设置为根节点的子节点</span><br>        root.setRightNode(treeNodeR);<br><br><span class="hljs-comment">//        为第二层的左节点创建两个子节点</span><br>        treeNodeL.setLeftNode(<span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>));<br>        treeNodeR.setRightNode(<span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>));<br><span class="hljs-comment">//        为第二层的右节点创建两个子节点</span><br>        treeNodeL.setLeftNode(<span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">6</span>));<br>        treeNodeR.setRightNode(<span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">7</span>));<br><span class="hljs-comment">//        前序遍历树</span><br>        binaryTree.frontShow();<br>        System.out.println(<span class="hljs-string">"=========="</span>);<br><span class="hljs-comment">//        中序遍历树</span><br>        binaryTree.midShow();<br><span class="hljs-comment">//        后序遍历树</span><br>        binaryTree.afterShow();<br>        System.out.println(<span class="hljs-string">"==========="</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br><span class="hljs-number">7</span><br>==========<br><span class="hljs-number">6</span><br><span class="hljs-number">2</span><br><span class="hljs-number">7</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span><br>===========<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Springboot+Dubbo启动时，连接Zookeeper时出现的问题：</title>
    <link href="/2020/11/06/%E5%85%B3%E4%BA%8EZookeeper%20not%20connected%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/11/06/%E5%85%B3%E4%BA%8EZookeeper%20not%20connected%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="关于Springboot-Dubbo启动的时候一些问题，连接Zookeeper时出现的问题："><a href="#关于Springboot-Dubbo启动的时候一些问题，连接Zookeeper时出现的问题：" class="headerlink" title="关于Springboot+Dubbo启动的时候一些问题，连接Zookeeper时出现的问题："></a>关于Springboot+Dubbo启动的时候一些问题，连接Zookeeper时出现的问题：</h3><p> <strong>异常信息：</strong></p><p>java.lang.IllegalStateExpection:Zookeeper not connected</p><p><strong>解决方案：</strong></p><p>　　1、 检查zk所在机的防火墙。 systemctl stop firewalld | service firewalld stop（这里使用的是CentOS8镜像）<br>　　2、 检查zk所在机的ip和yml配置中的ip是否对应<br>　　3、 检查zk是否成功启动。 $zk_home/bin/zkServer.sh status -&gt; standalone<br>　　4、 在yml配置文件中增加新的配置，提高连接zk的访问超时时间。（有可能是虚拟机网络不稳定造成连接zk的时候，出现超时）。dubbo中的默认超时配置是3秒。<br>　　　　dubbo:<br>　　　　　　config-center:<br>　　　　　　　　timeout: 10000 # 单位是毫秒。<br>　　5、 在启动类型上增加新的注解， @EnableDubboConfig。 人为强制要求dubbo-spring-boot-starter扫描配置并加载。 dubbo是自动扫描配置并加载的。<br>　　6、 修改版本。降低spring-boot和dubbo-spring-boot-starter版本。（版本问题是win10操作系统对权限管理加强后，导致的结果。）<br>　　　　6.1、 先降低dubbo-spring-boot-starter 到 2.7.3 -&gt; 2.7.0<br>　　　　6.2、 再考虑降低spring-boot版本 到 2.2.0 -&gt; 2.1.10 -&gt; 2.0.2</p><p><strong>同时虚拟机的网络也是有一定的影响，如何提高虚拟机的网络稳定呢？</strong>　　</p><p>　　1、 关闭不必要的网卡<br>　　2、 关闭所有的热点软件<br>　　3、 关闭windows防火墙</p><p><strong>我遇到的问题：</strong></p><p>关闭防火墙！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC面试题总结</title>
    <link href="/2020/10/21/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/21/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h5 id="1-谈一谈你对于SpringMVC的理解？"><a href="#1-谈一谈你对于SpringMVC的理解？" class="headerlink" title="1. 谈一谈你对于SpringMVC的理解？"></a>1. 谈一谈你对于SpringMVC的理解？</h5><p><strong>Model1时代：</strong></p><p>在此阶段，整个web应用几乎全都是用Jsp页面写成的，使用很少的Java Bean进行处理数据库的连接和访问等操作，此模式下Jsp既是控制层又是视图层，所以，此模式存在很多问题，比如：</p><p>1） 将控制逻辑层和视图层混在一起，导致代码重用率极低；</p><p>2）前端和后端相互依赖，难以进行测试笔并且开发效率极低；</p><p><strong>Model2时代：</strong></p><p>在此阶段， 出现了Java Bean（Model–包含系统设计的数据，也就是Dao（Mapper+bean/pojo+Jsp（View–视图层 ，只用来进行展示页面）+Servlet（Controller，处理用户请求发送给服务器，然后返回数据给Jsp展示给用户）这就是早期的JavaWeb MVC开发模式；</p><p><strong>SpringMVC框架（Struts2）</strong></p><p>MVC是一种设计模式，SpringMVC 是一个非常优秀的MVC框架，可以帮助我们快速进行开发，大大提高了效率，所有我们一般把后端项目分为：Service层（处理业务）、Dao/Mapper（数据库操作）、Entity/Pojo（实体类）、Controller（控制层返回数据给前台页面）；</p><h5 id="2-说一下Spring-MVC的工作原理？"><a href="#2-说一下Spring-MVC的工作原理？" class="headerlink" title="2. 说一下Spring MVC的工作原理？"></a>2. 说一下Spring MVC的工作原理？</h5>]]></content>
    
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring面试题总结</title>
    <link href="/2020/10/19/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/19/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring面试题总结："><a href="#Spring面试题总结：" class="headerlink" title="Spring面试题总结："></a>Spring面试题总结：</h3><h5 id="1-什么是Spring框架？"><a href="#1-什么是Spring框架？" class="headerlink" title="1. 什么是Spring框架？"></a>1. 什么是Spring框架？</h5><p>Spring（Spring FrameWork）是一种轻量级的开发框架，可以提高开发人员的开发效率以及系统的维护性，它是很多模块的集合，使用这些模块可以很方便的进行开发；</p><p><strong>模块：</strong></p><ul><li>核心容器</li><li>数据访问/集成</li><li>WebkAOP（面向切面编程）</li><li>工具</li><li>消息</li><li>测试模块</li></ul><h5 id="2-列举几个重要的Spring模块？"><a href="#2-列举几个重要的Spring模块？" class="headerlink" title="2.列举几个重要的Spring模块？"></a>2.列举几个重要的Spring模块？</h5><p><a href="https://imgchr.com/i/BRYbOU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/05/BRYbOU.png" alt="Spring模块.png"></a></p><ul><li>Spring Core： 基础模块，Spring其他所有的功能都要依赖此库。主要提供IOC依赖注入的功能；</li><li>Spring Aspects:  :与AspectJ的集成提供支持；</li><li>Spring AOP: 实现面向切面编程；</li><li>Spring JDBC：Java数据库连接；</li><li>Spring JMS：Java消息服务；</li><li>Spring ORM：用于支持Hibernate 等ORM工具；</li><li>Spring Web：为创建web应用程序提供支持；</li><li>Spring Test：提供了对JUnit和TestNG测试的支持；</li></ul><h5 id="3-RestController-和-Controller注解的区别："><a href="#3-RestController-和-Controller注解的区别：" class="headerlink" title="3.@RestController 和@Controller注解的区别："></a>3.@RestController 和@Controller注解的区别：</h5><ul><li>单独使用@Controller注解而不加ResponseBody的情况下，会返回一个视图页面，属于比较传统的springMVC项目，对应于前后不分离的情况；</li><li>使用@RestController注解返回的是一个Json或者 XML形式的数据，但是RestController注解返回的是一个对象，对象数据以Json或者XML形式写入HTTP响应中，属于目前比较常用的前后端分离开发；</li><li>@Controller +@ResponseBody （通过转换器进行转换为相对应的格式）返回JSON 或 XML 形式数据；</li></ul><h5 id="4-谈谈你对Spring-IOC-和Spring-AOP的理解？"><a href="#4-谈谈你对Spring-IOC-和Spring-AOP的理解？" class="headerlink" title="4. 谈谈你对Spring IOC 和Spring AOP的理解？"></a>4. 谈谈你对Spring IOC 和Spring AOP的理解？</h5><p><strong>IOC</strong><br>IOC（控制反转）是一种设计思想，目的是将原本在程序中<strong>手动创建对象</strong>的工作交给Spring框架来管理；IOC容器是Spring容器实现IOC的载体，IOC实际上就是一个<strong>Map（key，value）</strong>，Map中存放各种对象；</p><p>IOC就像一个工厂，当我们需要创建对象的时候，只需要进行配置XML配置文件或者注解（使用SpringBoot的时会使用注解进行配置，大大提高了开发效率）就行，不用考虑是怎么创建出来的对象；所以大大降低了开发难度、提高了项目的可维护性；</p><p><strong>AOP</strong></p><p>AOP( 面向切面编程)  可以有效减少系统的重复代码，降低模块之间的耦合度，有利于未来的代码扩展和可维护性；</p><p>Spring AOP 是基于<strong>动态代理</strong>的，如果要代理的对象实现了<strong>某一个接口</strong>，那么SpringAOP会使用<strong>JDK Proxy **的方式进行创建代理对象；而对于没有实现接口的对象，此时SpringAOP会使用</strong>Cglib<strong>生成一个被代理对象的</strong>子类**进行代理；</p><p>注意：可以使用AspectJ框架进行操作！</p><p><a href="https://imgchr.com/i/Bhwk34" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bhwk34.png" alt="动态创建对象的两种方式.png"></a></p><h5 id="5-SpringAOP-和AspectJ-AOP-有什么区别？"><a href="#5-SpringAOP-和AspectJ-AOP-有什么区别？" class="headerlink" title="5.SpringAOP 和AspectJ AOP 有什么区别？"></a>5.SpringAOP 和AspectJ AOP 有什么区别？</h5><ul><li>前者属于运行时增强，后者属于编译时增强；</li><li>前者是基于代理进行操作的，后者是基于字节码进行操作的</li><li>前者效率较低 ，后者效率较高；</li><li>如果是切面比较少的情况下，两者的差异不是很大，但是如果是漆面比较多的情况下，推荐使用AspectJ；</li></ul><h5 id="6-SpringBean的作用域有哪些？"><a href="#6-SpringBean的作用域有哪些？" class="headerlink" title="6. SpringBean的作用域有哪些？"></a>6. SpringBean的作用域有哪些？</h5><ul><li>Singleton：唯一的bean实例，在Spring 中所有的bean默认都是单例的；</li><li>prototype：每次请求都会创建一个新的bean实例；</li><li>session：每次HTTP请求都会产生一个新的bean实例，该bean仅在当前Http session内有效；</li><li>request：每次HTTP请求都会产生一个新的bean实例，该bean仅在当前Http request内有效；</li><li>global-session： 全局session；</li></ul><h5 id="7-Spring-中单例的bean线程安全问题你有了解么？"><a href="#7-Spring-中单例的bean线程安全问题你有了解么？" class="headerlink" title="7. Spring 中单例的bean线程安全问题你有了解么？"></a>7. Spring 中单例的bean线程安全问题你有了解么？</h5><p>单例bean会存在线程安全问题，主要是因为多线程在操作同一个对象时，对<strong>当前对象的非静态成员变量的写操作</strong>会存在线程安全问题；</p><p><strong>解决：</strong></p><ul><li>在bean中尽量少使用可变的成员变量（不太现实）；</li><li>在类中定义一个ThreadLocal的成员变量，将可变的成员变量放在ThreadLocal中（推荐！）</li></ul><h5 id="8-Component和-Bean-的区别："><a href="#8-Component和-Bean-的区别：" class="headerlink" title="8. @Component和@Bean 的区别："></a>8. @Component和@Bean 的区别：</h5><ul><li>前者的作用对象是类；后者的作用对象是方法；</li><li>前者需要通过扫描类所在的路径将bean对象装配到Spring容器中，也可以使用@ComponentScan增加一个类扫描的路径；</li><li>使用后者比前者的自定义更强，多数场景下需要使用后者进行注解;</li></ul><p><strong>使用@Bean注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> Class TestBean&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();<br>&#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码相当于XML配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transferService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.acme.TransferServiceImpl"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="9-将一个类声明为Spring-的bean的注解有哪些？"><a href="#9-将一个类声明为Spring-的bean的注解有哪些？" class="headerlink" title="9. 将一个类声明为Spring 的bean的注解有哪些？"></a>9. 将一个类声明为Spring 的bean的注解有哪些？</h5><ul><li>@AutoWired ：自动进行装配；</li><li>@Component：如果不知道要标注的bean属于哪个层，可以使用此注解进行标注；</li><li>@Service：业务层，主要涉及一些复杂的逻辑，需要用到Dao/Mapper层；</li><li>@Controller：对应Spring MVC的控制层，接收用户请求并调用Service层返回数据给前端页面；</li><li>@Repository： 对应数据库，需要使用到Dao/Mapper层；</li></ul><h5 id="10-Spring-中Bean的生命周期？"><a href="#10-Spring-中Bean的生命周期？" class="headerlink" title="10. Spring 中Bean的生命周期？"></a>10. Spring 中Bean的生命周期？</h5><p><a href="https://imgchr.com/i/BbFFW6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/09/BbFFW6.png" alt="Spring bean 声明周期图示.png"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高并发下Redis可能存在的问题以及解决方案</title>
    <link href="/2020/10/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8BRedis%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8BRedis%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="高并发下Redis可能存在的问题及解决方案"><a href="#高并发下Redis可能存在的问题及解决方案" class="headerlink" title="高并发下Redis可能存在的问题及解决方案"></a>高并发下Redis可能存在的问题及解决方案</h3><h5 id="1-缓存穿透（面试问题）"><a href="#1-缓存穿透（面试问题）" class="headerlink" title="1. 缓存穿透（面试问题）"></a>1. 缓存穿透（面试问题）</h5><p>在实际开发中，添加缓存工具的目的，减少对数据库的访问次数，增加访问效率。</p><p>肯定会出现Redis中不存在的缓存数据。例如：访问id=-1的数据。可能出现绕过redis依然频繁访问数据库的情况，称为缓存穿透，多出现在查询为null的情况不被缓存时。</p><p>解决办法：</p><p><strong>如果查询出来为null数据，把null数据依然放入到redis缓存中，同时设置这个key的有效时间比正常有效时间更短一些。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(list==<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-comment">// key value 有效时间 时间单位</span><br>    redisTemplate.opsForValue().set(navKey,<span class="hljs-keyword">null</span>,<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    redisTemplate.opsForValue().set(navKey,result,<span class="hljs-number">7</span>,TimeUnit.DAYS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-缓存击穿（面试问题）"><a href="#2-缓存击穿（面试问题）" class="headerlink" title="2. 缓存击穿（面试问题）"></a>2. 缓存击穿（面试问题）</h5><p>实际开发中，考虑redis所在服务器中内存压力，都会设置key的有效时间。一定会出现键值对过期的情况。如果正好key过期了，此时出现大量并发访问，这些访问都会去访问数据库，这种情况称为缓存击穿。</p><p>解决办法：</p><p><strong>永久数据。加锁。防止出现数据库的并发访问。</strong> </p><h5 id="2-1-ReentrantLock（重入锁）"><a href="#2-1-ReentrantLock（重入锁）" class="headerlink" title="2.1 ReentrantLock（重入锁）"></a>2.1 ReentrantLock（重入锁）</h5><p>JDK对于并发访问处理的内容都放入了java.util.concurrent中</p><p>ReentrantLock性能和synchronized没有区别的，但是API使用起来更加方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                test2(<span class="hljs-string">"第一个线程111111"</span>);<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                test2(<span class="hljs-string">"第二个线程222222"</span>);<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">20000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(String who)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">if</span>(lock.isLocked()) &#123;<br>            System.out.println(<span class="hljs-string">"开始执行:"</span> + who);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">"执行完:"</span> + who);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-解决缓存击穿实例代码"><a href="#2-2-解决缓存击穿实例代码" class="headerlink" title="2.2 解决缓存击穿实例代码"></a>2.2 解决缓存击穿实例代码</h5><p>只有在第一次访问时和Key过期时才会访问数据库。对于性能来说没有过大影响，因为平时都是直接访问redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">selectByid</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>    String key = <span class="hljs-string">"item:"</span>+id;<br>    <span class="hljs-keyword">if</span>(redisTemplate.hasKey(key))&#123;<br>        <span class="hljs-keyword">return</span> (Item) redisTemplate.opsForValue().get(key);<br>    &#125;<br>    lock.lock();<br>    <span class="hljs-keyword">if</span>(lock.isLocked()) &#123;<br>        Item item = itemDubboService.selectById(id);<br>        <span class="hljs-comment">// 由于设置了有效时间，就可能出现缓存击穿问题</span><br>        redisTemplate.opsForValue().set(key, item, <span class="hljs-number">7</span>, TimeUnit.DAYS);<br>        lock.unlock();<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>    <span class="hljs-comment">// 如果加锁失败，为了保护数据库，直接返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-缓存雪崩（面试问题"><a href="#3-缓存雪崩（面试问题" class="headerlink" title="3. 缓存雪崩（面试问题)"></a>3. 缓存雪崩（面试问题)</h5><p>在一段时间内，出现大量缓存数据失效，这段时间内数据库的访问频率骤增，这种情况称为缓存雪崩。</p><p>解决办法：</p><p>永久生效。</p><p>自定义算法，例如：随机有效时间。让所有key尽量避开同一时间段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> seconds = random.nextInt(<span class="hljs-number">10000</span>);<br>redisTemplate.opsForValue().set(key, item, <span class="hljs-number">100</span>+ seconds, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化策略</title>
    <link href="/2020/10/02/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/02/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis的持久化策略（面试题）"><a href="#Redis的持久化策略（面试题）" class="headerlink" title="Redis的持久化策略（面试题）"></a>Redis的持久化策略（面试题）</h3><p>Redis不仅仅是一个内存型数据库，还具备持久化能力。</p><p>Redis每次启动时都会从硬盘存储文件中把数据读取到内存中。运行过程中操作的数据都是内存中的数据</p><p>一共包含两种持久化策略：RDB 和 AOF</p><h3 id="1-RDB（Redis-DataBase）"><a href="#1-RDB（Redis-DataBase）" class="headerlink" title="1 RDB（Redis DataBase）"></a>1 RDB（Redis DataBase）</h3><p>rdb模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到dump.rdb文件中。当redis重启后会自动加载dump.rdb文件中内容到内存中。</p><p>用户可以使用SAVE（同步）或BGSAVE（异步）手动保存数据。</p><p>可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。<br>　　例如：<br>　　save 900 1<br>　　save 300 10<br>　　save 60 10000<br>　　那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行。计时单位是必须要执行的时间，save 900 1 ，每900秒检测一次。在并发量越高的项目中Redis的时间参数设置的值要越小。<br>　　服务器在900秒之内，对数据库进行了至少1次修改<br>　　服务器在300秒之内，对数据库进行了至少10次修改<br>　　服务器在60秒之内，对数据库进行了至少10000次修改。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>rdb文件是一个紧凑文件，直接使用rdb文件就可以还原数据。</p><p>数据保存会由一个子进程进行保存，不影响父进程做其他事情。</p><p>恢复数据的效率要高于aof</p><p>总结：性能要高于AOF</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每次保存点之间导致redis不可意料的关闭，可能会丢失数据。</p><p>由于每次保存数据都需要fork()子进程，在数据量比较大时可能会比较耗费性能。</p><h3 id="AOF（AppendOnly-File）"><a href="#AOF（AppendOnly-File）" class="headerlink" title="AOF（AppendOnly File）"></a>AOF（AppendOnly File）</h3><p>AOF默认是关闭的是 <strong>appendonly no</strong>，需要在配置文件redis.conf中开启AOF。Redis支持AOF和RDB同时生效，如果同时存在，AOF优先级高于RDB（Redis重新启动时会使用AOF进行数据恢复）</p><p>AOF原理：监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中，同时会把命令记录到日志中。即使突然出现问题，由于日志文件中已经记录命令，下一次启动时也可以按照日志进行恢复数据，由于内存数据和硬盘数据实时同步，即使出现意外情况也不需要担心。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>相对RDB数据更加安全。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>相同数据集AOF要大于RDB。</p><p>相对RDB可能会慢一些。</p><h4 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h4><p>修改redis.conf中。</p><p>appendonly yes 开启aof</p><p>appendfilename 设置aof数据文件，名称随意。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shiro权限管理</title>
    <link href="/2020/09/12/Shiro/"/>
    <url>/2020/09/12/Shiro/</url>
    
    <content type="html"><![CDATA[<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><h5 id="1-什么是shiro"><a href="#1-什么是shiro" class="headerlink" title="1. 什么是shiro?"></a>1. 什么是shiro?</h5><p>shiro是一个简单易用的安全框架；</p><p>主要应用： <strong>认证（Authentication）、授权（Authorization）、</strong>加密（cryptography）、会话管理（Session Manager）</p><h5 id="2-shiro的架构（核心重点）"><a href="#2-shiro的架构（核心重点）" class="headerlink" title="2. shiro的架构（核心重点）"></a>2. shiro的架构（核心重点）</h5><p><img src="https://s1.ax1x.com/2020/09/24/0p1EdJ.md.png" alt="shiro架构图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis从入门到入坑</title>
    <link href="/2020/09/10/Mybatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%91/"/>
    <url>/2020/09/10/Mybatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h3 id="Mybatis从入门到入坑"><a href="#Mybatis从入门到入坑" class="headerlink" title="Mybatis从入门到入坑"></a>Mybatis从入门到入坑</h3><h4 id="1-什么是Mybatis？"><a href="#1-什么是Mybatis？" class="headerlink" title="1. 什么是Mybatis？"></a>1. 什么是Mybatis？</h4><p>Mybatis是一个优秀的==持久层框架==，封装了==JDBC==，使用起来肥肠之方便；</p><p><strong>关键词：</strong></p><p><strong>持久层（使用Mybatis访问Mapper层，相当于使用JDBC访问Dao层），</strong></p><p><strong>持久化（可以永久存储，永不丢失，位置在磁盘中），</strong></p><p><strong>ORM(Object-Relationl Mapping)对象关系映射</strong></p><h4 id="2-Mybatis的优缺点："><a href="#2-Mybatis的优缺点：" class="headerlink" title="2.Mybatis的优缺点："></a>2.Mybatis的优缺点：</h4><p><strong>优点：</strong></p><ul><li>SQL语句从程序代码中彻底分离出来，可以重用；</li><li>提供了XML标签，支持编写动态的SQl语句；</li><li>提供映射标签<mapper>xxxx</mapper>,实现对象与数据库ORM之间的关系映射；</li></ul><p><strong>缺点：</strong></p><p>代码相比较于JDBC会减少，但是相对于==hibernate==代码量比较多，需要程序员自己编写SQl语句</p><h4 id="3-如何使用："><a href="#3-如何使用：" class="headerlink" title="3. 如何使用："></a>3. 如何使用：</h4><p><strong>步骤：</strong></p><ul><li><strong>配置环境：</strong></li></ul><ol><li>加入Jar包</li></ol><p>包括：Mybatis的Jar包+Mysql数据库的Jar包+日志文件Log4J包+Junit单元测试Jar包（16个）</p><ol start="2"><li>配置文件mybatis.cfg.xml</li><li>映射文件mapper.xml,需要指定映射文件的位置：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/bjsxt/mapper/EmployeeMapper.xml"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>准备log4j ,在配置文件中指定log4j的位置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"LOG4J"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>进行DML和DQL的操作</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><br></code></pre></td></tr></table></figure><h4 id="4-mybatis的配置完善"><a href="#4-mybatis的配置完善" class="headerlink" title="4. mybatis的配置完善"></a>4. mybatis的配置完善</h4>]]></content>
    
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Ajax处理异步请求</title>
    <link href="/2020/07/15/%E4%BD%BF%E7%94%A8Ajax%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/07/15/%E4%BD%BF%E7%94%A8Ajax%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h5 id="1、引入Ajax"><a href="#1、引入Ajax" class="headerlink" title="1、引入Ajax"></a>1、引入Ajax</h5><ul><li><strong>问题1：C-S进行数据交互的流程：</strong></li></ul><p>1.浏览器发起请求</p><p>2.服务器端接收请求，并进行解析</p><p>3.服务器根据请求内容进行调用资源</p><p>4.服务器将处理的请求响应给浏览器</p><p>5.浏览器接收响应结果并且进行解析</p><p>6.最后浏览器将响应的结果展示给用户</p><ul><li><strong>问题2：目前触发浏览器发起请求的方式三种？</strong></li></ul><p>1.使用form进行验证；</p><p>2.使用超链接；</p><p>3.在js代码中使用window.location.href(相当于form表单中的get请求）；</p><p>弊端！！！</p><p>所要实现的内容会被直接解析并且覆盖原有的内容，只显示最新内容，所以会导致数据的不准确；</p><ul><li><strong>问题3：如何解决上述弊端？</strong></li></ul><p>使用Ajax！！！</p><ul><li><strong>问题4：什么是Ajax技术？</strong></li></ul><p>是由浏览器解析并且基于Js代码编写的页面局部刷新技术</p><ul><li><p><strong>问题5：Ajax技术的特点？</strong></p><ul><li>由浏览器发起HTTP请求的技术</li><li>响应结果按照预先声明进行响应</li><li>由浏览器解析运行，跟服务器没有任何关系</li><li>响应结果是提前给浏览器的</li><li>简单易用</li></ul></li><li><p><strong>问题6：如何使用Ajax？</strong></p><p>1.创建Ajax请求的逻辑代码，由用户触发；</p><p>2.创建Ajax响应的逻辑代码，提前给浏览器</p><p>Ajax的核心是XMLHttpRequest对象(XHR)，XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据，jQuery 提供多个与 AJAX 有关的方法，通过 jQuery Ajax 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中</p><p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p><p><strong>代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">jQuery.ajax(...)<br>      部分参数：<br>            url：请求地址<br>            type：请求方式，GET、POST（1.9.0之后用method）<br>        headers：请求头<br>            data：要发送的数据<br>    contentType：即将发送信息至服务器的内容编码类型(默认: "application/x-www-form-urlencoded; charset=UTF-8")<br>          async：是否异步<br>        timeout：设置请求超时时间（毫秒）<br>      beforeSend：发送请求前执行的函数(全局)<br>        complete：完成之后执行的回调函数(全局)<br>        success：成功之后执行的回调函数(全局)<br>          error：失败之后执行的回调函数(全局)<br>        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型<br>        dataType：将服务器端返回的数据转换成指定类型<br>          "xml": 将服务器端返回的内容转换成xml格式<br>          "text": 将服务器端返回的内容转换成普通文本格式<br>          "html": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。<br>        "script": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式<br>          "json": 将服务器端返回的内容转换成相应的JavaScript对象<br>        "jsonp": JSONP 格式使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数<br></code></pre></td></tr></table></figure><p>1.配置web.xml 和 springmvc的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"> <br></code></pre></td></tr></table></figure><p>2.编写一个AjaxController</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.kuang.controller"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">id</span>=<span class="hljs-string">"internalResourceViewResolver"</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.导入Jquery</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://code.jquery.com/jquery-3.1.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4、编写index.jsp测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$Title$<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  &lt;%--&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;--%&gt;<br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a1</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="javascript">           $.post(&#123;</span><br><span class="actionscript">               url:<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/a1"</span>,</span><br><span class="javascript">               data:&#123;<span class="hljs-string">'name'</span>:$(<span class="hljs-string">"#txtName"</span>).val()&#125;,</span><br><span class="actionscript">               success:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data,status)</span> </span>&#123;</span><br>                   alert(data);<br>                   alert(status);<br>              &#125;<br>          &#125;);<br>      &#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">%--onblur：失去焦点触发事件--%</span>&gt;</span><br>用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txtName"</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">"a1()"</span>/&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>5.启动tomcat进行测试! 打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回的结果！测试成功！</p><p><strong>SpringMVC 实现</strong></p><p>实体类User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> Integer age;<br>   <span class="hljs-keyword">private</span> String sex;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>获取一个集合对象，展示到前端页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/a2"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">ajax2</span><span class="hljs-params">()</span></span>&#123;<br>   List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();<br>   list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"icoop01"</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"男"</span>));<br>   list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"icoop02"</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"男"</span>));<br>   list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"icoop03"</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"男"</span>));<br>   <span class="hljs-keyword">return</span> list; <span class="hljs-comment">//由于@RestController注解，将list转成json格式返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前端页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"获取数据"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80%"</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><br><span class="javascript">   $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">       $(<span class="hljs-string">"#btn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">           $.post(<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/a2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-built_in">console</span>.log(data)</span><br><span class="actionscript">               <span class="hljs-keyword">var</span> html=<span class="hljs-string">""</span>;</span><br><span class="actionscript">               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;data.length ; i++) &#123;</span><br><span class="actionscript">                   html+= <span class="hljs-string">"&lt;tr&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].name + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].age + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].sex + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;/tr&gt;"</span></span><br>              &#125;<br><span class="javascript">               $(<span class="hljs-string">"#content"</span>).html(html);</span><br>          &#125;);<br>      &#125;)<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注册提示效果</p></blockquote><p>前端页面login.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"获取数据"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80%"</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><br><span class="javascript">   $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">       $(<span class="hljs-string">"#btn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">           $.post(<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/a2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-built_in">console</span>.log(data)</span><br><span class="actionscript">               <span class="hljs-keyword">var</span> html=<span class="hljs-string">""</span>;</span><br><span class="actionscript">               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;data.length ; i++) &#123;</span><br><span class="actionscript">                   html+= <span class="hljs-string">"&lt;tr&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].name + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].age + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;td&gt;"</span> + data[i].sex + <span class="hljs-string">"&lt;/td&gt;"</span> +</span><br><span class="actionscript">                       <span class="hljs-string">"&lt;/tr&gt;"</span></span><br>              &#125;<br><span class="javascript">               $(<span class="hljs-string">"#content"</span>).html(html);</span><br>          &#125;);<br>      &#125;)<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>​    </p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>Ajax</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统</title>
    <link href="/2020/07/05/Liunx%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/07/05/Liunx%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h5 id="1-为什么选择Liunx-作为操作系统？"><a href="#1-为什么选择Liunx-作为操作系统？" class="headerlink" title="1. 为什么选择Liunx 作为操作系统？"></a>1. 为什么选择Liunx 作为操作系统？</h5><p>开源免费</p><p>相比于windows更加安全 更加稳定 据说十年可以不关机依旧流畅运行；</p><h5 id="2-Liunx常用命令："><a href="#2-Liunx常用命令：" class="headerlink" title="2. Liunx常用命令："></a>2. Liunx常用命令：</h5><ul><li>cd 进入某一个目录<ul><li>cd ~进入用户目录</li><li>cd / 进入磁盘根目录</li><li>cd .. 返回上一级</li></ul></li><li>pwd 显示当前所在路径的根路径</li><li>clear 清屏</li><li>ls 以平铺的方式显示当前目录所包含的内容</li><li>ll 以列表的形式显示当前目录所包含的内容</li><li>ls -la 以列表的形式显示当前目录所包含的内容以及隐藏的内容</li><li>mkdir 新建一个空文件夹 语法：mkdir -p 路径：如果路径中包含了不存在的路径，则自动创建；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解Java反射机制</title>
    <link href="/2020/06/18/%E8%AF%A6%E8%A7%A3Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/18/%E8%AF%A6%E8%A7%A3Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Java反射机制：<strong>无法</strong>获取类和对象的基本信息，通过反射可以<strong>动态</strong>获取类的信息；</p></blockquote><p><strong>应用场景：</strong></p><ul><li>动态创建对象</li><li>动态调用方法</li><li>动态操作属性</li><li>动态操作构造器</li></ul><p><strong>主要实现类：</strong></p><p>位于<strong>java.lang.reflect</strong>包中</p><ul><li>Class类</li><li>Constructor类</li><li>Method类 </li><li>Field类</li></ul><p><strong>主要操作:</strong></p><ul><li><strong>获取类对象</strong>三种方式:<ul><li>通过forName()；</li><li>直接通过类名.class()；</li><li>通过对象名.getclass()；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz=Class.forName(<span class="hljs-string">"类的完整路径"</span>);<br>Class clazz=Dog<span class="hljs-class">.<span class="hljs-keyword">class</span>()</span>;<br>Class clazz=dog.getclass();<br></code></pre></td></tr></table></figure><ul><li><strong>创建类对象</strong><ul><li>通过调用类的无参constructor（）；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj=clazz.getConstructor().newInstance();<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：调用constructor.setAccessible( true );方法，可以突破封装性的限制。</p></blockquote><ul><li><p>反射优缺点：</p><ul><li>优点：可以动态获取类的信息，进行创建类对象，并进行一系列操作；</li><li>共同优缺点：突破了封装性；</li></ul></li><li><p><strong>操作类对象</strong></p><ul><li><strong>操作属性</strong></li></ul><p>getField(“指定属性”);//操作指定的public属性</p><p>getFields()；//操作所有的public属性</p><p>getDeclaredField(“ 指定属性”);//可以操作指定的<strong>所有权限</strong>的属性</p><p>getDeclaredFields();//可以操作所有的属性</p><ul><li><strong>执行方法&lt;最常用&gt;</strong></li></ul><p>getMethod(“指定属性”);//操作指定的public方法</p><p>getMethods()；//操作所有的public方法</p><p>getDeclaredMethod(“ 指定属性”);//可以操作指定的<strong>所有权限</strong>的方法</p><p>getDeclaredmethods();//可以操作所有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">Method method = clazz.getMethod(<span class="hljs-string">"introduce"</span>);<br>System.out.println(method);<br>Method method2 = clazz.getMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;<br>System.out.println(method2);<br>method.invoke(object);<br>Object result = method2.invoke(object, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);<br>System.out.println(result);<br></code></pre></td></tr></table></figure><blockquote><p>注意事项： 每个Method对象对应一个方法，获得Method对象后，可以调用其<strong>invoke( )</strong> 来调用对应方法；</p></blockquote><ul><li>操作泛型（不常用，不做赘述）</li><li><strong>突破操作（数组）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestArrayType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-string">"Java开发"</span>);<br>        list.add(<span class="hljs-string">"Web前端开发"</span>);<br>        list.add(<span class="hljs-string">"大数据开发"</span>);<br>        list.add(<span class="hljs-string">"算法"</span>);<br>        System.out.println(list);<br><br>        <span class="hljs-comment">//通过反射调用方法</span><br>        Class clazz = list.getClass();<br>        Method method = clazz.getMethod(<span class="hljs-string">"add"</span>, Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        method.invoke(list, <span class="hljs-number">1047</span>);<br>        method.invoke(list, <span class="hljs-keyword">new</span> String(<span class="hljs-string">"VB开发岗"</span>));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程与高并发</title>
    <link href="/2020/06/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/06/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><strong>1.什么是线程</strong></p><p>通俗讲，即一个程序里不同的执行路径</p><p><strong>2.创建线程的三种方式</strong></p><ol><li>继承Thread类</li><li>实现Runnable接口（Lambda表达式）</li><li>通过线程池启动</li></ol><p><strong>3.几个常见方法</strong></p><p>sleep（Long mills）让给别的线程先运行，回到就绪状态</p><p>yield（） 谦让退出，进入就绪状态（工程中基本不用）</p><p>join（）  插队，强行进入线程</p><p><strong>4.线程的状态</strong></p><p>新建–&gt;就绪状态–&gt;运行–&gt;死亡</p><p><strong>5.不要强制stop（）关闭线程，应该是正常执行完毕之后自动关闭</strong></p><p> <strong>6.Interrupt中断处理，并不是直接中断，而是如果有异常的话需要自己手动去处理</strong></p><p><strong>7.synchronized关键字</strong></p><p>含义：<strong>给某个对象加锁</strong></p><p>使用场景：1.synchronized（对象）</p><p>​                    2.synchronized（this）</p><p>​                    3.可以把2 替换为 public synchronized void method( ){ }</p><p>在static方法中加入synchronized关键字，锁的是当前类的class对象 </p><p>是线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2020/06/11/JavaSE_IO%E6%B5%81/"/>
    <url>/2020/06/11/JavaSE_IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>IO流，顾名思义，就是InputStream、OutputStream，是用来操作数据的一种形式；Java中的流一般位于Java.util包中</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h5 id="1-IO流的概述"><a href="#1-IO流的概述" class="headerlink" title="1.IO流的概述"></a>1.IO流的概述</h5><p><strong>字节流</strong>：顶级父类     InputStream    OutputStream</p><p><strong>字符流</strong>：顶级父类     Reader    Writer</p><p>顶级父类都是<strong>抽象类</strong>，不可以new对象，必须由子类实现；</p><hr><p><strong>File类的使用</strong></p><p>表示文件或者文件夹，获取文件或者文件夹的属性，实现对文件、文件夹的创建和删除操作；</p><p>方法：</p><p>getname（）获取文件或者文件夹的名字</p><p>length（）长度</p><p>exists（）是否存在</p><p>listFiles（）获取文件夹下的文件列表</p><p>delete（）删除操作</p><p>mkdirs（）创建目录</p><p>createNewFile（）创建文件</p><p>方法很多，</p><blockquote><p>注意事项：</p><p>1.File不仅可以指向一个文件，也可以指向一个文件夹（作为一个<strong>文件</strong>对待）；</p><p>2.File不能对文件的内容进行操作，需要借助<strong>IO流</strong>实现；</p></blockquote><hr><h5 id="2-文件流"><a href="#2-文件流" class="headerlink" title="2.文件流"></a>2.文件流</h5><p><strong>文件字节流：FileInputStream和FileOutputStream</strong></p><p><strong>操作流程：</strong></p><p>1.新建一个文件字节流对象，包括文件字节输入和输出</p><p>2.新建一个中转站（相当于一个容器，存储字节），通过循环进行遍历文件</p><p>3.最后一定要关闭流，这和<strong>GC</strong>回收机制没有关系；</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.icoop.io;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> I.C&amp;OOP</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/11</span><br><span class="hljs-comment"> * 测试文件字节流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建一个流</span><br>        InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"D:/test.txt"</span>);<br>        OutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"D:/test2.txt"</span>, <span class="hljs-keyword">true</span>);<br>        <br>        <span class="hljs-comment">//中继站</span><br>        <span class="hljs-keyword">byte</span>[] ch = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> length = inputStream.read(ch);<br>        <span class="hljs-keyword">while</span> (length != -<span class="hljs-number">1</span>) &#123;<br>            outputStream.write(ch, <span class="hljs-number">0</span>, length);<br>            length = inputStream.read(ch);<br>        &#125;<br>        <span class="hljs-comment">//关闭流</span><br>        inputStream.close();<br>        outputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>1.中转站可以是一个字节，可以使字节数组，自行选择，不过一般用<strong>字节数组</strong>比较多，因为效率比较高；</p><p>2.常规操作只能是在覆盖源文件内容，要想进行追加操作，则在创建<strong>输出流对象</strong>的时候，追加true；</p><p><code>OutputStream outputStream = new FileOutputStream(new File(&quot;D:/Video2.mp4&quot;),true);</code></p></blockquote><p><strong>文件字符流：FileReader和FileWriter</strong></p><p><strong>操作流程:</strong></p><p>类似于文件字节流，此处不再进行赘述</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.icoop.io;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> I.C&amp;OOP</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/11</span><br><span class="hljs-comment"> * 测试字符流</span><br><span class="hljs-comment"> * 并进行异常处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStream2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建流</span><br>        <span class="hljs-comment">//进行追加操作而不是直接覆盖，此处引入了try-with-resources异常处理</span><br>        <span class="hljs-keyword">try</span> (Reader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:/test.txt"</span>));<br>             Writer writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:/test2.txt"</span>))) &#123;<br>            <span class="hljs-comment">//操作流</span><br>            <span class="hljs-comment">//使用一个数字存储，效率低下</span><br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-comment">//使用输入流读取一个字符char ！！，不是字节</span><br>            n = reader.read();<br>            <span class="hljs-keyword">while</span> (n != -<span class="hljs-number">1</span>) &#123;<br>                writer.write(n);<br>                n = reader.read();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException exception) &#123;<br>            exception.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException exception) &#123;<br>            exception.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>1.其实<strong>只有字节流</strong>，没有字符流，字符流的底层还是字节流；</p><p>2.字节流可以完成所有类型文件的操作，而字符流一般处理中文的文本文件；</p><p>3.JDk1.7引入了新的异常处理，<strong>try-with-resources</strong>，最大的特点是：简单方便</p><p>直接可以将操作的流对象放入（Object）中，并且无需进行显示的finally语句，直接可以省略</p><p>执行流程入如上；</p></blockquote><h5 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3.缓冲流"></a>3.缓冲流</h5><p><strong>文件字节缓冲流    BufferedInputStream和BufferedOutputStream</strong></p><p><strong>原理：</strong></p><p>依赖于<strong>输入和输出缓冲区</strong>的数据存放，极大的提高了执行效率；</p><p>在进行关闭流的时候，只需要关闭高层流即可；</p><p>刷新缓冲区（一般不需要手动刷新，因为底层均有有一个flush方法）；</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCopy5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//1.创建一个输入流和输出流</span><br>      InputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/JDK_API.CHM"</span>));<br>      OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/JDK_API2.CHM"</span>));<br><span class="hljs-comment">//默认输入缓冲区大小8192</span><br>      BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis); <br><span class="hljs-comment">//默认输出缓冲区大小8192</span><br>      BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);       <br>        <span class="hljs-comment">//2.使用输入流和输出流完成文件复制</span><br>        <span class="hljs-keyword">int</span> n;<br>        n = bis.read();<span class="hljs-comment">//读取一个字节，赋给n</span><br>        <span class="hljs-keyword">while</span>(n != -<span class="hljs-number">1</span>)&#123;<br>            bos.write(n);<br>            n = bis.read();<br>        &#125;<br>        <span class="hljs-comment">//3.关闭输入流和输出流</span><br>        bis.close();<br>        bos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文件字符缓冲流    BufferedReader和BufferedWriter</strong></p><p><strong>操作流程：</strong></p><p>通过文件字符缓冲流进行数据的读写操作，并可以<strong>按行</strong>输出；</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCopy6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>         <span class="hljs-comment">//创建两个流</span><br>        BufferedReader br = <br>       <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/sqlnet.log"</span>)));<br>        BufferedWriter bw = <br>                <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"e:/sqlnet2.log"</span>));        <br>        <span class="hljs-comment">//中转站就是一个字符串，存储一行数据</span><br>        <span class="hljs-comment">//先读一行</span><br>        String str =  br.readLine();<br>        <span class="hljs-keyword">while</span>(str != <span class="hljs-keyword">null</span> )&#123;<br>            <span class="hljs-comment">//再写一行</span><br>            bw.write(str);<br>            <span class="hljs-comment">//bw.write("\r\n");不同操作系统中换行符是不同的,所以此处使用newLine();</span><br>            bw.newLine(); <br>            <span class="hljs-comment">//再读一行</span><br>            str = br.readLine();<span class="hljs-comment">//!!!</span><br>        &#125;<br>        <span class="hljs-comment">//关闭两个流</span><br>        br.close();<br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>1.在进行大量字符文件缓冲处理操作的时候，如果想要按行输出，则使用<strong>newLine（）</strong>；</p><p>2.str = br.readLine()，词条语句的意思是：再读取一行；有返回值String，一定要写<strong>返回值</strong>，否则会变成死循环；</p></blockquote><h5 id="4-数据流和对象流"><a href="#4-数据流和对象流" class="headerlink" title="4.数据流和对象流"></a>4.数据流和对象流</h5><p><strong>数据流    DataInputStream和DataOutputStream</strong></p><p><strong>对象流    ObjectInputStream和ObjectOutputStream</strong></p><p><em>非重点内容，了解即可，不再进行详细的整理；</em></p><blockquote><p>总结：</p><p>1.都是<strong>处理流</strong>，不是节点流</p><p>2.数据流只能操作基本数据类型和String，而对象流可以操作对象</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2020/06/09/%E9%9B%86%E5%90%88/"/>
    <url>/2020/06/09/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h5 id="1-集合的引入和ArrayList"><a href="#1-集合的引入和ArrayList" class="headerlink" title="1.集合的引入和ArrayList"></a>1.集合的引入和ArrayList</h5><ul><li><h5 id="集合和数组的比较"><a href="#集合和数组的比较" class="headerlink" title="集合和数组的比较"></a>集合和数组的比较</h5></li></ul><blockquote><p><strong>面试题</strong>：数组和集合的联系与区别</p><p>联系：</p><p>两者都可以存储基本数据类型和引用数据类型；</p><p>区别：</p><ol><li>数组长度必须指定初始化，且长度固定 ；</li><li>数组采用连续存储空间，删除和添加效率低下；</li><li>数组无法直接保存映射关系；</li></ol></blockquote><ul><li><h5 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h5></li></ul><p>位于Java.util包中；</p><p>结构：</p><ul><li><h5 id="List的主要实现类"><a href="#List的主要实现类" class="headerlink" title="List的主要实现类"></a>List的主要实现类</h5></li></ul><p>List特征：有序，不唯一</p><p>ArrayList：分配连续空间，实现长度可变的数组</p><p>LinkedList：采用双向链表的存储方式</p><h5 id="2-ArrayList和LinkedListSet"><a href="#2-ArrayList和LinkedListSet" class="headerlink" title="2.ArrayList和LinkedListSet"></a>2.ArrayList和LinkedListSet</h5><table><thead><tr><th align="center">实现类</th><th align="center">ArrayList</th><th align="center">LinkedList</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">查询、遍历效率高（按照索引）</td><td align="center">增加删除效率高</td></tr><tr><td align="center">缺点</td><td align="center">增加、删除效率低、按照内容查询效率低</td><td align="center">查询、遍历效率低</td></tr></tbody></table><h5 id="3-集合的使用"><a href="#3-集合的使用" class="headerlink" title="3.集合的使用"></a>3.集合的使用</h5><p><strong>遍历集合</strong></p><ul><li>使用普通for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> List&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        System.out.println(list.size());<br>        <span class="hljs-comment">//使用普通for循环</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;list.size;i++)&#123;<br>            System.out.println(list.get(i));<br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用foreach循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> List&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        System.out.println(list.size());<br>        <span class="hljs-comment">//使用foreach</span><br>        <span class="hljs-keyword">for</span>(Integer num:list)&#123;<br>            System.out.println(num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用Iterator迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> List&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        System.out.println(list.size());<br>        <span class="hljs-comment">//使用迭代器</span><br>        Itarator&lt;Integet&gt; it = list.itarator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>             System.out.println(it.next());<br>        &#125;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用lambda表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> List&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        System.out.println(list.size());<br>        <span class="hljs-comment">//使用lambda表达式</span><br>       list.foreach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他常见方法</strong></p><p>add(index，元素)    指定位置添加</p><p>addAll(新的集合)    将新的集合添加到原集合的后边</p><p>remove(index)    删除指定元素</p><p>removeAll(集合)    删除集合</p><p>contains(Object o)     如果列表包含指定的元素，则返回 true</p><p>isEmpty()    是否为空</p><p>get（index）获取指定元素</p><p>size（）获取集合中元素的个数</p><blockquote><p>LinkedList集合与ArrayList集合方法类似，在此不进行赘述，但是需要注意：</p><p>1.大量的根据索引<strong>查询</strong>的操作，大量的<strong>遍历</strong>操作（按照索引0–n-1逐个查询一般），建议使用<strong>ArrayList</strong>;<br>2.如果存在较多的<strong>添加、删除操作</strong>，建议使用<strong>LinkedList</strong>;</p></blockquote><h5 id="4-Set集合的原理"><a href="#4-Set集合的原理" class="headerlink" title="4.Set集合的原理"></a>4.Set集合的原理</h5><h5 id="5-Map集合的使用"><a href="#5-Map集合的使用" class="headerlink" title="5.Map集合的使用"></a>5.Map集合的使用</h5><h5 id="6-Map和Set集合源码"><a href="#6-Map和Set集合源码" class="headerlink" title="6.Map和Set集合源码"></a>6.Map和Set集合源码</h5><h5 id="7-集合的其他内容"><a href="#7-集合的其他内容" class="headerlink" title="7.集合的其他内容"></a>7.集合的其他内容</h5><h5 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8.泛型"></a>8.泛型</h5><h5 id="9-JDK8新特征"><a href="#9-JDK8新特征" class="headerlink" title="9.JDK8新特征"></a>9.JDK8新特征</h5>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式详解</title>
    <link href="/2020/06/09/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/06/09/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda简介"><a href="#Lambda简介" class="headerlink" title="Lambda简介"></a>Lambda简介</h3><p>Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。</p><p>JDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。</p><h3 id="对接口的要求"><a href="#对接口的要求" class="headerlink" title="对接口的要求"></a>对接口的要求</h3><p>虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。<strong>Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法</strong></p><blockquote><p>jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。</p></blockquote><h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p>修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。</p><h3 id="Lambda-基础语法"><a href="#Lambda-基础语法" class="headerlink" title="Lambda 基础语法"></a>Lambda 基础语法</h3><p>我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**多参数无返回*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoReturnMultiParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**无参无返回值*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoReturnNoParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**一个参数无返回*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoReturnOneParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**多个参数有返回值*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReturnMultiParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/*** 无参有返回*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReturnNoParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**一个参数有返回值*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReturnOneParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
